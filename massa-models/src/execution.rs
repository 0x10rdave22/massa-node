use std::{
    collections::{BTreeSet, VecDeque},
    fmt::Display,
};

use crate::{output_event::SCOutputEvent, Amount, Slot};
use serde::{Deserialize, Serialize};

/// Execution info about an address
pub struct ExecutionAddressInfo {
    /// parallel balance of the address
    pub parallel_balance: Amount,
    /// sequential balance of the address
    pub sequential_balance: Amount,
    /// number of rolls the address has
    pub roll_count: u64,
    /// datastore keys of the address
    pub datastore_keys: BTreeSet<Vec<u8>>,
}

impl std::fmt::Display for ExecutionAddressInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "parallel balance: {}", self.parallel_balance)?;
        writeln!(f, "sequential balance: {}", self.sequential_balance)?;
        writeln!(f, "roll count: {}", self.roll_count)?;
        writeln!(f, "datastore keys:")?;
        for k in &self.datastore_keys {
            match String::from_utf8(k.clone()) {
                Ok(v) => writeln!(f, "\t`{}`", v)?,
                Err(_) => writeln!(f, "\t(non-UTF8)")?,
            }
        }
        Ok(())
    }
}

/// The result of the read-only execution.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ReadOnlyResult {
    /// An error occurred during execution.
    Error(String),
    /// The result of a successful execution.
    /// TODO: specify result.
    Ok,
}

/// The response to a request for a read-only execution.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteReadOnlyResponse {
    /// The slot at which the read-only execution occurred.
    pub executed_at: Slot,
    /// The result of the read-only execution.
    pub result: ReadOnlyResult,
    /// The output events generated by the read-only execution.
    pub output_events: VecDeque<SCOutputEvent>,
}

impl Display for ExecuteReadOnlyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Executed at slot: {}", self.executed_at)?;
        writeln!(
            f,
            "Result: {}",
            match &self.result {
                ReadOnlyResult::Error(e) =>
                    format!("an error occurred during the execution: {}", e),
                ReadOnlyResult::Ok => "ok".to_string(),
            }
        )?;
        if !self.output_events.is_empty() {
            writeln!(f, "Generated events:",)?;
            for event in self.output_events.iter() {
                writeln!(f, "{}", event)?; // id already displayed in event
            }
        }
        Ok(())
    }
}
