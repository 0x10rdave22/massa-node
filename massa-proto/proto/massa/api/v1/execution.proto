// Copyright (c) 2023 MASSA LABS <info@massa.net>

syntax = "proto3";

package massa.api.v1;

import "slot.proto";

option csharp_namespace = "Com.Massa.Api.V1";
option go_package = "github.com/massalabs/massa/api/v1;v1";
option java_multiple_files = true;
option java_package = "com.massa.api.v1";
option objc_class_prefix = "GRPC";
option php_namespace = "Com\\Massa\\Api\\V1";
option ruby_package = "Com::Massa::Api::V1";
option swift_prefix = "GRPC";

// SlotExecutionOutput
message SlotExecutionOutput {
    // Status
    repeated ExecutionOutputStatus status = 1;
    // Executed slot output
    ExecutionOutput execution_output = 2;
}

// FinalizedExecutionOutput
message FinalizedExecutionOutput {
  // Slot
  Slot slot = 1;
}

// ExecutionOutput
message ExecutionOutput {
  // Slot
  Slot slot = 1;
  // Block id at that slot (optional)
  optional string block_id = 2;
  // Events emitted by the execution step
  repeated ScExecutionEvent events = 3;
  // State changes caused by the execution step
  StateChanges state_changes = 4;
}

// ScExecutionEvent
message ScExecutionEvent {
  // Sc execution context
  ScExecutionEventContext context = 1;
  // json data string
  string data = 2;
}

// ScExecutionEvent context
message ScExecutionEventContext {
  // base58 encoded slot(period + thread) + index_in_slot
  string id = 1;
  // When was it generated
  Slot origin_slot = 2;
  // Block id if there was a block at that slot (optional)
  optional string block_id = 3;
  // Index of the event in the slot
  fixed64 index_in_slot = 4;
  // Call stack addresses. most recent at the end
  repeated string call_stack = 5;
  // Origin operation id (optional)
  optional string origin_operation_id = 6;
  // Status
  repeated ScExecutionEventStatus status = 7;
}

// ScExecutionEventStatus type enum
enum ScExecutionEventStatus {
  SC_EXECUTION_EVENT_STATUS_UNSPECIFIED = 0; // Defaut enum value
  SC_EXECUTION_EVENT_STATUS_FINAL = 1; // Final status
  SC_EXECUTION_EVENT_STATUS_READ_ONLY = 2; // Read only status
  SC_EXECUTION_EVENT_STATUS_FAILURE = 3; // Failure status
}

// ExecutionOutputStatus type enum
enum ExecutionOutputStatus {
  EXECUTION_OUTPUT_STATUS_UNSPECIFIED = 0; // Defaut enum value
  EXECUTION_OUTPUT_STATUS_CANDIDATE = 1; // Candidate status
  EXECUTION_OUTPUT_STATUS_FINAL = 2; // Final status
}

// StateChanges
message StateChanges {
  // Asynchronous pool changes
  repeated AsynPoolChange async_pool_changes = 2;
  // Executed operations changes
  ExecutedOpsChanges executed_ops_changes = 5;
}

// ExecutedOpsChanges
message ExecutedOpsChanges {
  // Executed operations
  repeated ExecutedOpsChangeEntry executed_ops = 1;
}

// ExecutedOpsChangeEntry
message ExecutedOpsChangeEntry {
  // OperationId
  string operation_id = 1;
  // ExecutedOpsChangeValue
  ExecutedOpsChangeValue value = 2;
}

// ExecutedOpsChangeValue
message ExecutedOpsChangeValue {
  // The status of the execution of the operation
  repeated OperationExecutionStatus status = 1;
  // Slot until which the operation remains valid (included)
  Slot slot = 2;
}

// OperationExecutionStatus type enum
enum OperationExecutionStatus {
  OPERATION_EXECUTION_STATUS_UNSPECIFIED = 0; // Defaut enum value
  OPERATION_EXECUTION_STATUS_SUCCESS = 1; // Success status
  OPERATION_EXECUTION_STATUS_FAILED = 2; // Failed only status
}

// AsynPoolChange
message AsynPoolChange {
  // Asynchronous pool changes
  AsyncPoolChangeEntry async_pool_change = 2;
}

// AsyncPoolChangeEntry
message AsyncPoolChangeEntry {
  // Async message id
  string async_message_id = 1;
  // AsyncPool message
  AsyncPoolChangeValue value = 2;
}

// AsyncPoolChangeValue
message AsyncPoolChangeValue {
  // The type of the change
  AsyncPoolChangeType type = 1;
  // AsyncPool message
  AsyncMessage async_message = 2;
}

// AsyncPoolChangeType type enum
enum AsyncPoolChangeType {
  ASYNC_POOL_CHANGE_TYPE_UNSPECIFIED = 0; // Defaut enum value
  ASYNC_POOL_CHANGE_TYPE_ADD = 1; // Add type
  ASYNC_POOL_CHANGE_TYPE_ACTIVATE = 2; // Activate only type
  ASYNC_POOL_CHANGE_TYPE_DELETE = 3; // Delete only type
}

// Asynchronous smart contract message
message AsyncMessage {
  // Slot at which the message was emitted
  Slot emission_slot = 1;

  // Index of the emitted message within the `emission_slot`.
  // This is used for disambiguate the emission of multiple messages at the same slot.
  fixed64 emission_index = 2;

  // The address that sent the message
  string sender = 3;

  // The address towards which the message is being sent
  string destination = 4;

  // the handler function name within the destination address' bytecode
  string handler = 5;

  // Maximum gas to use when processing the message
  fixed64 max_gas = 6;

  // Fee paid by the sender when the message is processed.
  fixed64 fee = 7;

  // Coins sent from the sender to the target address of the message.
  // Those coins are spent by the sender address when the message is sent,
  // and credited to the destination address when receiving the message.
  // In case of failure or discard, those coins are reimbursed to the sender.
  fixed64 coins = 8;

  // Slot at which the message starts being valid (bound included in the validity range)
  Slot validity_start = 9;

  // Slot at which the message stops being valid (bound not included in the validity range)
  Slot validity_end = 10;

  // Raw payload data of the message
  bytes data = 11;

  // Trigger that define whenever a message can be executed (optional)
  AsyncMessageTrigger trigger = 12;

  // Boolean that determine if the message can be executed. For messages without filter this boolean is always true.
  // For messages with filter, this boolean is true if the filter has been matched between `validity_start` and current slot.
  bool can_be_executed = 13;

  // Hash of the message
  string hash = 14;
}

// Structure defining a trigger for an asynchronous message
message AsyncMessageTrigger {
    // Filter on the address
    string address = 1;
    // Filter on the datastore key (optional)
    optional bytes datastore_key = 2;
}