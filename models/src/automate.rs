use crate::block::BlockHeaderContent;
use crate::Slot;
use crypto::hash::Hash;
use std::collections::HashMap;
use std::convert::From;
use std::marker::PhantomData;

//define all header state
#[derive(Debug, Clone)]
struct NotChecked;
#[derive(Debug, Clone)]
struct InProcessing;

//header data processed by the automate.
#[derive(Debug, Clone)]
struct Header<State> {
    pub hash: Hash,
    pub slot: Slot,
    pub parents: Vec<Hash>,
    state: PhantomData<State>,
}

//manage NotChecked state header process
impl Header<NotChecked> {
    pub fn new(hash: Hash, slot: Slot, parents: Vec<Hash>) -> Self {
        Header {
            hash,
            slot,
            parents,
            state: PhantomData,
        }
    }

    pub fn checkdb(
        self,
        current_header_list: &HashMap<Hash, Header<InProcessing>>,
        _db: &ExempleHeaderDb,
    ) -> Option<AutomateEvent> {
        //test bidon pour la démo
        if !current_header_list.contains_key(&self.parents[0]) {
            let new_header = Header::<InProcessing>::from(self);
            Some(AutomateEvent::NewInprocessing(new_header))
        } else {
            Some(AutomateEvent::OutEvent(OutEvent::HeaderReady(self.hash)))
        }
    }
}

//manage InProcessing state header process
impl Header<InProcessing> {
    pub fn check_parent_integrated_event(self, parent: &Hash) -> Option<AutomateEvent> {
        //test bidon pour la démo
        if self.parents.contains(parent) {
            Some(AutomateEvent::InEvent(InEvent::ReceiveHeader(
                self.hash,
                self.slot,
                self.parents,
            )))
        } else {
            None
        }
    }
}

//define all state possible transition between header.
impl From<Header<NotChecked>> for Header<InProcessing> {
    fn from(header: Header<NotChecked>) -> Self {
        Header {
            hash: header.hash,
            slot: header.slot,
            parents: header.parents,
            state: PhantomData,
        }
    }
}

impl From<Header<InProcessing>> for Header<NotChecked> {
    fn from(header: Header<InProcessing>) -> Self {
        Header {
            hash: header.hash,
            slot: header.slot,
            parents: header.parents,
            state: PhantomData,
        }
    }
}

//Structure simulée pour la démo.
struct ExempleHeaderDb {
    db: HashMap<Hash, BlockHeaderContent>,
}

impl ExempleHeaderDb {
    pub fn contains_header(&self, hash: &Hash) -> bool {
        self.db.contains_key(&hash)
    }
}

#[derive(Debug, Clone)]
enum InEvent {
    ReceiveHeader(Hash, Slot, Vec<Hash>),
    ParentIntegrated(Hash),
}

#[derive(Debug, Clone)]
enum OutEvent {
    HeaderReady(Hash),
    DiscardHeader(Hash),
}

//l'automatate
struct HeaderCheckAutomate {
    //    notchecked_list: HashMap<Hash, Header<NotChecked>>,
    inprocessing_list: HashMap<Hash, Header<InProcessing>>,
}

impl HeaderCheckAutomate {
    //process all event generated by all header state processing.
    pub fn process_in_event(&mut self, inevent: InEvent, db: &ExempleHeaderDb) -> Vec<OutEvent> {
        let mut out_event_list = vec![];
        let mut automate_event_list = vec![AutomateEvent::InEvent(inevent)];
        while automate_event_list.len() > 0 {
            //println!("automate_event_list:{:?}", automate_event_list);
            match automate_event_list.pop() {
                Some(AutomateEvent::InEvent(event)) => match event {
                    InEvent::ReceiveHeader(hash, slot, parents) => {
                        let new_header = Header::<NotChecked>::new(hash, slot, parents);
                        new_header
                            .checkdb(&self.inprocessing_list, db)
                            .map(|event| automate_event_list.push(event));
                    }
                    InEvent::ParentIntegrated(parent) => {
                        let hash_list: Vec<Hash> = self.inprocessing_list.keys().cloned().collect();
                        for hash in hash_list {
                            if let Some(header) = self.remove(hash) {
                                header
                                    .check_parent_integrated_event(&parent)
                                    .map(|event| automate_event_list.push(event));
                            }
                        }
                    }
                },
                Some(AutomateEvent::OutEvent(event)) => out_event_list.push(event),
                Some(AutomateEvent::NewInprocessing(header)) => {
                    self.inprocessing_list.insert(header.hash, header);
                }
                None => (),
            }
        }
        out_event_list
    }

    fn remove(&mut self, hash: Hash) -> Option<Header<InProcessing>> {
        self.inprocessing_list.remove(&hash)
    }
}

//for internal automate event process
#[derive(Debug, Clone)]
enum AutomateEvent {
    InEvent(InEvent),
    OutEvent(OutEvent),
    NewInprocessing(Header<InProcessing>),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_all_transitions() {
        let mut automate = HeaderCheckAutomate {
            inprocessing_list: HashMap::new(),
        };

        //pour la demo.
        // - reception d'un header de child1
        // - reception du header du parent
        // - envoie event ParentIntegrated du parent.
        // -> le child est vérifié (HeaderReady).

        let db = ExempleHeaderDb { db: HashMap::new() };
        let parent1 = Hash::hash("parent1".as_bytes());
        let child1 = Hash::hash("child1".as_bytes());
        let event1 = InEvent::ReceiveHeader(child1, Slot::new(1, 0), vec![parent1, parent1]);
        let event_list = automate.process_in_event(event1, &db);
        assert_eq!(0, event_list.len());
        let event_parent = InEvent::ReceiveHeader(parent1, Slot::new(0, 0), vec![parent1, parent1]);
        let event_list = automate.process_in_event(event_parent, &db);
        assert_eq!(0, event_list.len());

        let event2 = InEvent::ParentIntegrated(parent1);
        let event_list = automate.process_in_event(event2, &db);
        //        println!("event_lsit:{:?}", event_list);
        assert_eq!(1, event_list.len());
        if let OutEvent::HeaderReady(child) = event_list[0] {
            assert_eq!(child1, child);
        } else {
            panic!("bad out event :{:?}", event_list[0]);
        }
    }
}
